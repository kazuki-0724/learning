<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テスト証跡Markdown生成ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        /* カスタムスタイル */
        body { font-family: "Inter", sans-serif; background-color: #f3f4f6; }
        .editor-container {
            max-width: 800px;
            margin: 0 auto;
        }
        #drawingCanvas {
            border: 2px solid #3b82f6;
            cursor: crosshair;
            background-color: #ffffff;
            touch-action: none; /* モバイルでのスクロール防止 */
        }
        /* 描画モードボタンのスタイル */
        .mode-button {
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .mode-button.active {
            border: 2px solid #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
            background-color: #eef2ff;
        }
        
        /* Markdownプレビューの基本スタイル */
        .markdown-preview h1, .markdown-preview h2 { font-size: 1.5rem; font-weight: 700; margin-top: 1.5rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        .markdown-preview h3 { font-size: 1.25rem; font-weight: 600; margin-top: 1rem; }
        .markdown-preview table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        .markdown-preview th, .markdown-preview td { border: 1px solid #d1d5db; padding: 8px; text-align: left; }
        .markdown-preview th { background-color: #f3f4f6; }
        .markdown-preview img { max-width: 100%; height: auto; display: block; margin: 1rem auto; border: 1px solid #ccc; border-radius: 4px; }
        .markdown-preview ul { list-style-type: disc; margin-left: 1.5rem; padding-left: 0; }
        .markdown-preview li { margin-bottom: 0.25rem; }

        /* マルチセレクトの見た目調整 */
        .multi-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }
        .multi-select-item {
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            padding-right: 40px; /* アイコン分のスペースを確保 */
        }
        .multi-select-item:hover {
            background-color: #f3f4f6;
        }
        .multi-select-item.selected {
            background-color: #bfdbfe; /* blue-200 */
            font-weight: 600;
        }
        .multi-select-item.focused {
            border: 2px solid #ef4444; /* red-500 */
            background-color: #fee2e2; /* red-100 */
        }
        .multi-select-item.has-image::after {
            content: '📸'; /* カメラ絵文字 */
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#10b981',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 sm:p-8">

    <div class="editor-container bg-white shadow-xl rounded-xl p-6 space-y-8">
        <h1 class="text-3xl font-extrabold text-gray-800 text-center border-b pb-4 mb-4">
            テスト証跡Markdown生成 (ケース別画像管理)
        </h1>

        <section class="space-y-4 p-4 border rounded-lg bg-blue-50">
            <h2 class="text-xl font-semibold text-primary">ステップ 1: テスト仕様の登録と選択</h2>
            
            <div class="p-3 border rounded-lg bg-white shadow-sm space-y-3">
                <h3 class="text-lg font-bold text-gray-700">A. テスト仕様書 (CSV) からインポート</h3>
                <label for="specImport" class="block text-sm font-medium text-gray-700">CSVファイルをアップロード</label>
                <input type="file" id="specImport" accept=".csv"
                       class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary/10 file:text-primary hover:file:bg-primary/20 cursor-pointer">
                <p id="specStatus" class="text-sm text-gray-500">※ 形式: 親番,枝番,"条件1|条件2","期待1|期待2"</p>
            </div>

            <div class="p-3 border rounded-lg bg-white shadow-sm space-y-3">
                <h3 class="text-lg font-bold text-gray-700">B. テストケースを手動で追加</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label for="manualParentId" class="block text-sm font-medium text-gray-700">親番</label>
                        <input type="text" id="manualParentId" placeholder="例: TC-002" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-2 border">
                    </div>
                    <div>
                        <label for="manualChildId" class="block text-sm font-medium text-gray-700">枝番</label>
                        <input type="text" id="manualChildId" placeholder="例: 03" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-2 border">
                    </div>
                </div>
                
                <div>
                    <label for="manualConditions" class="block text-sm font-medium text-gray-700">テスト条件 (改行または "|" 区切り)</label>
                    <textarea id="manualConditions" rows="3" placeholder="例: ユーザーは管理者権限を持つ&#10;商品Aは在庫切れ" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-2 border"></textarea>
                </div>
                
                <div>
                    <label for="manualExpectations" class="block text-sm font-medium text-gray-700">想定される結果 (改行または "|" 区切り)</label>
                    <textarea id="manualExpectations" rows="3" placeholder="例: エラーメッセージが表示される&#10;処理が中断される" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-2 border"></textarea>
                </div>

                <button id="addManualTestCase" class="w-full px-4 py-2 bg-indigo-500 text-white rounded-lg text-sm font-medium hover:bg-indigo-600 transition shadow-md">
                    テストケースをリストに追加
                </button>
            </div>

            <div class="h-px bg-gray-200 my-4"></div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">C. テストケースの選択 (複数選択可)</label>
                    <p class="text-xs text-red-500 mb-1 font-bold">⚠️ 赤枠: 画像編集中のケース (切り替え時に自動保存されます)</p>
                    <div id="testCaseList" class="multi-select-list mt-1 bg-white">
                        <p class="p-3 text-gray-500">仕様書/手動でテストケースを追加してください</p>
                    </div>
                </div>
                <div>
                    <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-2">証跡画像アップロード</label>
                    <input type="file" id="imageUpload" accept="image/*"
                           class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary/10 file:text-primary hover:file:bg-primary/20 cursor-pointer">
                    <p class="text-sm text-gray-500 mt-2">※ 選択中のテストケースの画像としてロードされます。</p>
                </div>
            </div>

            <div id="testCaseDetails" class="p-3 bg-white rounded-lg border border-gray-200 mt-4 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-2">
                    <span id="focusIndicator" class="inline-block px-3 py-1 bg-red-500 text-white rounded-full text-xs mr-2">編集フォーカス中</span>
                    選択中のテストケース詳細: <span id="selectedId" class="text-primary font-mono"></span>
                </h3>
                <p class="text-sm text-gray-500 italic mb-2">※ このケースにアップロードされた画像がCanvasに表示されます。</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div>
                        <p class="font-medium text-gray-600">テスト条件 (Conditions):</p>
                        <ul id="conditionList" class="list-disc ml-5 mt-1 text-gray-800"></ul>
                    </div>
                    <div>
                        <p class="font-medium text-gray-600">想定される結果 (Expected):</p>
                        <ul id="expectationList" class="list-disc ml-5 mt-1 text-gray-800"></ul>
                    </div>
                </div>
            </div>

        </section>

        <section class="space-y-4 p-4 border rounded-lg shadow-inner" id="canvasSection" style="display:none;">
            <h2 class="text-xl font-semibold text-primary">ステップ 2: 画像のマークアップ (ケース: <span id="currentFocusId" class="font-mono text-red-500">未選択</span>)</h2>

            <div class="flex flex-wrap gap-4 p-3 bg-gray-100 rounded-lg">
                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium text-gray-700">モード:</label>
                    <div class="inline-flex space-x-2 rounded-lg bg-white p-1 shadow-sm">
                        <button id="mode-freehand" data-mode="freehand" class="mode-button active px-3 py-1 rounded-lg text-sm font-medium" title="フリーハンド描画">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                        </button>
                        <button id="mode-straight" data-mode="straight" class="mode-button px-3 py-1 rounded-lg text-sm font-medium" title="直線描画">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path></svg>
                        </button>
                        <button id="mode-rect" data-mode="rect" class="mode-button px-3 py-1 rounded-lg text-sm font-medium" title="長方形描画">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"></path></svg>
                        </button>
                    </div>
                </div>

                <div class="flex items-center space-x-2">
                    <label class="text-sm font-medium text-gray-700">色:</label>
                    <input type="color" id="colorPicker" value="#ff0000" class="w-8 h-8 rounded-full border-none cursor-pointer">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="lineWidth" class="text-sm font-medium text-gray-700">太さ:</label>
                    <input type="range" id="lineWidth" min="1" max="20" value="5" class="w-20 cursor-pointer">
                    <span id="lineWidthValue" class="text-sm text-gray-600">5</span>
                </div>
                <button id="clearCanvas" class="flex items-center px-4 py-2 bg-red-500 text-white rounded-full text-sm font-medium hover:bg-red-600 transition shadow-md">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    マークアップをクリア
                </button>
            </div>

            <div class="flex justify-center items-center overflow-auto">
                <canvas id="drawingCanvas" class="w-full"></canvas>
            </div>
            <p id="canvasMessage" class="text-center text-sm text-red-500 font-medium hidden">※ 画像がアップロードされていません。</p>
        </section>


        <section class="space-y-4 p-4 border rounded-lg bg-green-50">
            <h2 class="text-xl font-semibold text-secondary">ステップ 3: Markdown出力 & プレビュー</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <button id="generateMarkdown" class="w-full px-5 py-3 bg-secondary text-white rounded-xl text-lg font-bold hover:bg-emerald-600 transition shadow-lg">
                    全件のMarkdownを生成 & プレビュー (画像を保存)
                </button>
                 <button id="downloadMarkdown" class="w-full px-5 py-3 bg-blue-600 text-white rounded-xl text-lg font-bold hover:bg-blue-700 transition shadow-lg disabled:bg-gray-400" disabled>
                    Markdownファイルをダウンロード
                </button>
            </div>
            <p class="text-sm text-gray-700">
                **💡 注記**: 「生成」ボタンを押すと、**現在編集中のケースの画像が確定・保存**され、登録されている**すべてのケース**の個別画像でレポートが作成されます。
            </p>

            <div>
                <label for="markdownOutput" class="block text-sm font-medium text-gray-700 mb-2">生成されたMarkdownコード</label>
                <textarea id="markdownOutput" rows="10" readonly placeholder="生成ボタンを押すと、ここにMarkdownが出力されます。"
                          class="mt-1 block w-full rounded-lg border-gray-300 shadow-inner p-3 font-mono text-sm bg-white"></textarea>
                <button id="copyMarkdown" class="mt-2 px-4 py-2 bg-gray-700 text-white rounded-full text-sm hover:bg-gray-800 transition" style="display:none;">
                    コードをコピー
                </button>
            </div>
            
            <div id="markdownPreviewArea" class="mt-8">
                <h3 class="text-xl font-semibold text-primary mb-3">Markdownプレビュー</h3>
                <div id="previewOutput" class="p-4 border border-gray-300 rounded-lg bg-white min-h-[100px] shadow-inner text-gray-800 markdown-preview">
                    <p class="text-gray-500 italic">生成ボタンを押すと、Markdownのレンダリング結果（画像を含む）がここに表示されます。</p>
                </div>
            </div
        </section>

        <div id="messageModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden" onclick="document.getElementById('messageModal').classList.add('hidden')">
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full mx-4" onclick="event.stopPropagation()">
                <h3 class="text-lg font-bold mb-3 text-gray-800">通知</h3>
                <p id="modalMessage" class="text-gray-600 mb-4"></p>
                <button onclick="document.getElementById('messageModal').classList.add('hidden')" class="w-full py-2 bg-primary text-white rounded-lg hover:bg-blue-600 transition">閉じる</button>
            </div>
        </div>

    </div>

    <script type="text/javascript">
        // グローバル変数の定義
        const $ = id => document.getElementById(id);

        const canvas = $('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = $('imageUpload');
        const generateButton = $('generateMarkdown');
        const downloadButton = $('downloadMarkdown');
        const copyButton = $('copyMarkdown');
        const clearButton = $('clearCanvas');
        const colorPicker = $('colorPicker');
        const lineWidthInput = $('lineWidth');
        const lineWidthValue = $('lineWidthValue');
        const markdownOutput = $('markdownOutput');
        const previewOutput = $('previewOutput');
        const canvasSection = $('canvasSection');
        const modeButtons = document.querySelectorAll('.mode-button');

        const specImport = $('specImport');
        const testCaseList = $('testCaseList');
        const detailContainer = $('testCaseDetails');
        const conditionList = $('conditionList');
        const expectationList = $('expectationList');
        const selectedId = $('selectedId');
        const specStatus = $('specStatus');
        const currentFocusId = $('currentFocusId');

        // 手動入力要素
        const addTestCaseButton = $('addManualTestCase'); 

        let testSpecs = []; // 各要素に evidenceImage, drawings, originalImageSrc を保持
        let selectedIndices = new Set(); 
        let focusedIndex = -1; // 現在編集中のテストケースのインデックス

        let originalImage = null; // Canvasの背景となる画像 (Imageオブジェクト)
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawings = []; // 現在Canvasに描画されているマークアップの配列
        let drawingMode = 'freehand';
        let currentDrawing = null;


        // ----------------------------------------------------
        // ユーティリティ
        // ----------------------------------------------------

        /**
         * カスタムメッセージモーダル (alert/confirmの代替)
         * @param {string} message - 表示するメッセージ
         * @param {boolean} isQuiet - ポップアップを表示せず、コンソールにのみログを出す (自動保存用)
         */
        function showMessage(message, isQuiet = false) {
            if (isQuiet) {
                console.log(message);
                return;
            }
            $('modalMessage').textContent = message;
            $('messageModal').classList.remove('hidden');
        }
        
        // ----------------------------------------------------
        // 描画ロジック (変更なし)
        // ----------------------------------------------------
        function redrawAll() {
            if (!originalImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvasSection.style.display = 'none';
                $('canvasMessage').classList.remove('hidden');
                return;
            }

            // Canvasサイズをコンテナ幅と画像比率に合わせて設定
            const containerWidth = canvasSection.clientWidth - 32; 
            canvas.width = containerWidth;
            const aspectRatio = originalImage.width / originalImage.height;
            const canvasHeight = containerWidth / aspectRatio;
            canvas.height = canvasHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            drawings.forEach(d => {
                ctx.strokeStyle = d.color;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.lineWidth = d.width;
                
                if (d.type === 'freehand') {
                    ctx.beginPath();
                    if (d.points.length > 0) {
                        ctx.moveTo(d.points[0].x, d.points[0].y);
                        for (let i = 1; i < d.points.length; i++) {
                            ctx.lineTo(d.points[i].x, d.points[i].y);
                        }
                    }
                    ctx.stroke();
                } else if (d.type === 'rect') {
                    const width = d.endX - d.startX;
                    const height = d.endY - d.startY;
                    ctx.strokeRect(d.startX, d.startY, width, height);
                } else if (d.type === 'straight') {
                    ctx.beginPath();
                    ctx.moveTo(d.startX, d.startY);
                    ctx.lineTo(d.endX, d.endY);
                    ctx.stroke();
                }
            });

            ctx.strokeStyle = colorPicker.value;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = parseInt(lineWidthInput.value);

            // Canvasが表示されている状態にする
            canvasSection.style.display = 'block';
            $('canvasMessage').classList.add('hidden');
        }

        function getCanvasCoordinates(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDrawing(clientX, clientY) {
            if (focusedIndex === -1 || !originalImage) { 
                showMessage("先にテストケースを選択し、画像をアップロードしてください。"); 
                return; 
            }
            isDrawing = true;
            const { x, y } = getCanvasCoordinates(clientX, clientY);
            [lastX, lastY] = [x, y];
            
            const color = colorPicker.value;
            const width = parseInt(lineWidthInput.value);

            if (drawingMode === 'freehand') {
                currentDrawing = { type: 'freehand', points: [{x, y}], color, width };
            } else if (drawingMode === 'rect' || drawingMode === 'straight') {
                currentDrawing = { type: drawingMode, startX: x, startY: y, endX: x, endY: y, color, width };
            }
        }

        function draw(clientX, clientY) {
            if (!isDrawing || !originalImage || !currentDrawing) return;

            const { x, y } = getCanvasCoordinates(clientX, clientY);

            if (drawingMode === 'freehand') {
                currentDrawing.points.push({x, y});
                
                ctx.strokeStyle = currentDrawing.color;
                ctx.lineWidth = currentDrawing.width;
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();

                [lastX, lastY] = [x, y];
                
            } else if (drawingMode === 'rect' || drawingMode === 'straight') {
                redrawAll(); 

                currentDrawing.endX = x;
                currentDrawing.endY = y;

                ctx.strokeStyle = currentDrawing.color;
                ctx.lineWidth = currentDrawing.width;

                if (drawingMode === 'rect') {
                    const width = currentDrawing.endX - currentDrawing.startX;
                    const height = currentDrawing.endY - currentDrawing.startY;
                    ctx.strokeRect(currentDrawing.startX, currentDrawing.startY, width, height);
                } else if (drawingMode === 'straight') {
                    ctx.beginPath();
                    ctx.moveTo(currentDrawing.startX, currentDrawing.startY);
                    ctx.lineTo(currentDrawing.endX, currentDrawing.endY);
                    ctx.stroke();
                }
            }
        }

        function stopDrawing() {
            if (isDrawing && currentDrawing) {
                // 描画データをdrawings配列に追加
                if (drawingMode === 'freehand' && currentDrawing.points.length > 1) {
                    drawings.push(currentDrawing);
                } else if ((drawingMode === 'rect' || drawingMode === 'straight') && (currentDrawing.startX !== currentDrawing.endX || currentDrawing.startY !== currentDrawing.endY)) {
                    drawings.push(currentDrawing);
                    redrawAll(); 
                } else {
                    if (drawingMode === 'rect' || drawingMode === 'straight') {
                        redrawAll();
                    }
                }
                
                // 描画データが更新されたので、次の保存時にevidenceImageが再生成される
                if (focusedIndex !== -1 && testSpecs[focusedIndex]) {
                    testSpecs[focusedIndex].evidenceImage = null;
                }
            }

            isDrawing = false;
            currentDrawing = null;
            [lastX, lastY] = [0, 0];
        }

        // ----------------------------------------------------
        // ステート管理ロジック
        // ----------------------------------------------------

        /**
         * 現在フォーカスされているケースのCanvasの状態をデータに保存する (自動保存)
         */
        function saveCurrentCanvasState() {
            if (focusedIndex === -1 || !testSpecs[focusedIndex] || !originalImage) return;

            // 描画履歴を保存
            testSpecs[focusedIndex].drawings = JSON.parse(JSON.stringify(drawings)); 

            // evidenceImageがnullの場合は、次のMarkdown生成時にマークアップ済み画像を生成する
            if (testSpecs[focusedIndex].evidenceImage === null) {
                // ここではBase64の再生成は行わず、描画履歴の保存に留める
                showMessage(`ケース ${testSpecs[focusedIndex].parentId}-${testSpecs[focusedIndex].childId} の描画履歴を保存しました。`, true); 
            } else {
                showMessage(`ケース ${testSpecs[focusedIndex].parentId}-${testSpecs[focusedIndex].childId} の状態を保存しました。`, true); 
            }
        }

        /**
         * 指定されたインデックスのケースの状態をCanvasにロードする
         * @param {number} index - ロードするテストケースのインデックス
         */
        function loadCanvasState(index) {
            const spec = testSpecs[index];
            if (!spec) return;

            // UIを更新
            updateFocusIndicator(index);
            currentFocusId.textContent = `${spec.parentId}-${spec.childId}`;
            
            // ロードする画像ソースを決定 (evidenceImage > originalImageSrc の順に優先)
            const imageSrcToLoad = spec.evidenceImage || spec.originalImageSrc;

            if (imageSrcToLoad) {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    drawings = spec.drawings || [];
                    redrawAll(); // 画像を背景に描画し、描画履歴を復元
                };
                img.src = imageSrcToLoad;
            } else {
                // 画像が全くない場合、Canvasをクリアして非表示
                originalImage = null;
                drawings = [];
                redrawAll(); 
            }
        }

        /**
         * テストケースリストのUIと詳細エリアのフォーカス状態を更新する
         * @param {number} focusedIndex - 現在フォーカスされているインデックス
         */
        function updateFocusIndicator(focusedIndex) {
            document.querySelectorAll('.multi-select-item').forEach((item, index) => {
                item.classList.remove('focused');
                if (index === focusedIndex) {
                    item.classList.add('focused');
                }
            });
        }


        // ----------------------------------------------------
        // データ操作ロジック
        // ----------------------------------------------------

        /**
         * CSVテキストを解析してデータ配列に変換する
         */
        function parseCSV(csv) {
            const lines = csv.split('\n').filter(line => line.trim() !== '');
            // ... (ヘッダーチェックなど、既存ロジックは維持) ...
            
            // 簡易ヘッダーチェック (今回は省略し、必ずデータが返ると仮定)
            if (lines.length < 1) return [];

            // 簡易的にコンマ区切りでパース（今回は簡易的に実装）
            const data = [];
            const header = (lines.shift() || '').split(',').map(h => h.trim());
            
            const pIdIdx = header.indexOf('親番');
            const cIdIdx = header.indexOf('枝番');
            const condIdx = header.indexOf('テスト条件');
            const expIdx = header.indexOf('想定される結果');

            if (pIdIdx === -1 || cIdIdx === -1 || condIdx === -1 || expIdx === -1) {
                 throw new Error("CSVヘッダーに'親番', '枝番', 'テスト条件', '想定される結果'のいずれかが不足しています。");
            }

            lines.forEach(line => {
                // CSVパーサーを使わず、簡易的にsplit(',')を使用 (引用符対応は困難なため、ユーザに形式を求める)
                const values = line.match(/(".*?"|[^",\r\n]+)(?=\s*,|\s*$)/g) || [];
                
                const conditions = (values[condIdx] || '').replace(/"/g, '').split('|').map(c => c.trim()).filter(c => c);
                const expectations = (values[expIdx] || '').replace(/"/g, '').split('|').map(e => e.trim()).filter(e => e);

                data.push({
                    parentId: (values[pIdIdx] || '').trim(),
                    childId: (values[cIdIdx] || '').trim(),
                    conditions: conditions,
                    expectations: expectations,
                    source: 'csv',
                    evidenceImage: null, // 個別画像用
                    drawings: [], // 個別描画履歴用
                    originalImageSrc: null // 初期画像用
                });
            });
            return data.filter(d => d.parentId && d.childId); // 必須項目がないものを除外
        }

        /**
         * 複数行またはパイプ区切りのテキストを配列に変換する (手動入力用)
         */
        function parseFactors(text) {
            if (!text) return [];
            return text.split(/[\n|]/)
                       .map(r => r.trim())
                       .filter(r => r); 
        }

        /**
         * 選択リストを更新する
         */
        function updateTestSelector() {
            testCaseList.innerHTML = '';
            // selectedIndices.clear(); // 選択状態は維持したい場合もあるためクリアしない

            if (testSpecs.length === 0) {
                testCaseList.innerHTML = '<p class="p-3 text-gray-500">仕様書/手動でテストケースを追加してください</p>';
                displayTestCaseDetails(null);
                focusedIndex = -1;
                return;
            }

            testSpecs.forEach((spec, index) => {
                const item = document.createElement('div');
                item.className = 'multi-select-item border-b last:border-b-0';
                if (selectedIndices.has(index)) {
                    item.classList.add('selected');
                }
                if (spec.evidenceImage || spec.originalImageSrc) {
                    item.classList.add('has-image');
                }
                item.setAttribute('data-index', index);
                item.textContent = `${spec.parentId}-${spec.childId} (${spec.source === 'csv' ? 'CSV' : '手動'})`;
                
                item.addEventListener('click', (e) => handleCaseSelection(e, index, item));
                testCaseList.appendChild(item);
            });

            // 既存のフォーカスを再ロード
            if (focusedIndex !== -1 && testSpecs[focusedIndex]) {
                loadCanvasState(focusedIndex);
                displayTestCaseDetails(testSpecs[focusedIndex]);
            } else {
                displayTestCaseDetails(null);
                currentFocusId.textContent = '未選択';
            }
        }

        /**
         * テストケース選択時の処理 (マルチセレクト & フォーカス切り替え)
         */
        function handleCaseSelection(e, index, item) {
            // --- 1. マルチセレクト処理 ---
            const isSelected = selectedIndices.has(index);

            if (e.shiftKey) {
                // Shiftキー: 全てを選択/選択解除のトグル (今回は簡略化し、トグルしない)
                // 最後にクリックされたものから現在のインデックスまでの範囲選択を実装することも可能だが、ここでは単一/全体トグルに留める
                if (selectedIndices.size === testSpecs.length) {
                    selectedIndices.clear();
                    document.querySelectorAll('.multi-select-item').forEach(i => i.classList.remove('selected'));
                } else {
                    selectedIndices.clear();
                    testSpecs.forEach((_, i) => selectedIndices.add(i));
                    document.querySelectorAll('.multi-select-item').forEach(i => i.classList.add('selected'));
                }
            } else {
                // 単一選択/トグル
                if (isSelected) {
                    selectedIndices.delete(index);
                    item.classList.remove('selected');
                } else {
                    selectedIndices.add(index);
                    item.classList.add('selected');
                }
            }

            // --- 2. フォーカス切り替え処理 ---
            // 選択/非選択にかかわらず、最後にクリックされたケースに編集フォーカスを当てる
            if (focusedIndex !== index) {
                // 現在フォーカスされているケースの状態を保存
                if (focusedIndex !== -1 && testSpecs[focusedIndex]) {
                    saveCurrentCanvasState();
                }

                // 新しいケースにフォーカスを設定
                focusedIndex = index;

                // 新しいケースの状態をロード
                loadCanvasState(index);
            }
            
            // 3. 最後にクリックされたケースの詳細を表示
            displayTestCaseDetails(testSpecs[index]);
        }


        /**
         * テストケースの詳細を表示エリアにレンダリングする
         * @param {object | null} spec - 選択されたテスト仕様
         */
        function displayTestCaseDetails(spec) {
            conditionList.innerHTML = '';
            expectationList.innerHTML = '';

            if (!spec) {
                detailContainer.classList.add('hidden');
                selectedId.textContent = '';
                return;
            }
            
            detailContainer.classList.remove('hidden');
            selectedId.textContent = `${spec.parentId}-${spec.childId}`;

            spec.conditions.forEach(cond => {
                const li = document.createElement('li');
                li.textContent = cond;
                conditionList.appendChild(li);
            });

            spec.expectations.forEach(exp => {
                const li = document.createElement('li');
                li.textContent = exp;
                expectationList.appendChild(li);
            });
        }

        /**
         * 選択されたテストケースのMarkdownを生成する共通ロジック
         * @param {object} spec - テストケースのデータ
         * @param {string} dataURL - 証跡画像Base64 URL
         * @returns {string} - 生成されたMarkdownテキスト
         */
        function generateSingleCaseMarkdown(spec, dataURL) {
            const parentId = spec.parentId;
            const childId = spec.childId;
            const imagePlaceholder = dataURL.startsWith('data:') ? 
                `![証跡画像：${parentId}-${childId}](${dataURL})` :
                `**画像なし** (このテストケースには画像がアップロードされていません)`;

            // Markdownリスト形式に変換
            const conditionsMarkdown = spec.conditions.map(c => `* ${c}`).join('\n');
            const expectationsMarkdown = spec.expectations.map(e => `* ${e}`).join('\n');

            return `## テスト証跡: ${parentId}-${childId}

| 項目 | 値 |
| :--- | :--- |
| **テスト親番** | \`${parentId}\` |
| **枝番** | \`${childId}\` |
| **登録元** | \`${spec.source === 'csv' ? 'CSVインポート' : '手動入力'}\` |

---

### 実行条件 (Test Conditions)

${conditionsMarkdown}

### 想定結果 (Expected Result)

${expectationsMarkdown}

---

### 証跡画像

${imagePlaceholder}

---

`;
        }
        
        // ----------------------------------------------------
        // イベントリスナー
        // ----------------------------------------------------

        // CSVインポート
        specImport.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const csvText = event.target.result;
                    const newSpecs = parseCSV(csvText);
                    testSpecs.push(...newSpecs); 
                    updateTestSelector();
                    specStatus.textContent = `✅ ${newSpecs.length}件のテストケースをインポートしました。総件数: ${testSpecs.length}`;
                    specStatus.classList.remove('text-gray-500', 'text-red-500');
                    specStatus.classList.add('text-secondary', 'font-bold');
                } catch (error) {
                    showMessage("CSVファイルの読み込みまたは解析に失敗しました。形式を確認してください。");
                    console.error('CSV Parsing Error:', error);
                    specStatus.textContent = "❌ CSVのインポートに失敗しました。";
                    specStatus.classList.remove('text-gray-500', 'font-bold', 'text-secondary');
                    specStatus.classList.add('text-red-500');
                }
            };
            reader.readAsText(file);
        });

        // テストケースの手動追加
        addTestCaseButton.addEventListener('click', () => {
            const parentId = $('manualParentId').value.trim();
            const childId = $('manualChildId').value.trim();
            const conditionsText = $('manualConditions').value.trim();
            const expectationsText = $('manualExpectations').value.trim();

            if (!parentId || !childId || !conditionsText || !expectationsText) {
                showMessage("親番、枝番、テスト条件、想定される結果のすべてを入力してください。");
                return;
            }

            const conditions = parseFactors(conditionsText);
            const expectations = parseFactors(expectationsText);

            if (conditions.length === 0 || expectations.length === 0) {
                showMessage("テスト条件と想定される結果を最低1つは入力してください。");
                return;
            }

            testSpecs.push({
                parentId: parentId,
                childId: childId,
                conditions: conditions,
                expectations: expectations,
                source: 'manual',
                evidenceImage: null,
                drawings: [],
                originalImageSrc: null
            });

            // 入力欄をクリア
            $('manualParentId').value = '';
            $('manualChildId').value = '';
            $('manualConditions').value = '';
            $('manualExpectations').value = '';

            updateTestSelector();
            showMessage(`テストケース ${parentId}-${childId} をリストに追加しました。`);
        });

        // 画像アップロード
        imageUpload.addEventListener('change', (e) => {
            if (focusedIndex === -1) {
                showMessage("先にテストケースをリストから選択してください。");
                e.target.value = null; 
                return;
            }
            
            const file = e.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // 証跡画像がない状態の初期画像としてspecに保存
                    testSpecs[focusedIndex].originalImageSrc = event.target.result;
                    testSpecs[focusedIndex].evidenceImage = null; // マークアップ前にリセット
                    testSpecs[focusedIndex].drawings = [];
                    
                    // Canvasをリロード
                    originalImage = img;
                    drawings = [];
                    redrawAll();
                    updateTestSelector(); // 画像があることを示すアイコンを更新
                    showMessage(`画像を ${testSpecs[focusedIndex].parentId}-${testSpecs[focusedIndex].childId} にロードしました。`);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Canvas描画イベント設定 (モバイル対応含む)
        canvas.addEventListener('mousedown', (e) => startDrawing(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => draw(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrawing(e.touches[0].clientX, e.touches[0].clientY);
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e.touches[0].clientX, e.touches[0].clientY);
        });
        canvas.addEventListener('touchend', stopDrawing);

        // Markdown一括生成
        generateButton.addEventListener('click', () => {
            // 1. 現在フォーカス中の状態を最後に保存し、マークアップ済み画像を生成
            if (focusedIndex !== -1 && originalImage) {
                testSpecs[focusedIndex].evidenceImage = canvas.toDataURL('image/png');
                testSpecs[focusedIndex].drawings = JSON.parse(JSON.stringify(drawings)); 
                showMessage(`ケース ${testSpecs[focusedIndex].parentId}-${testSpecs[focusedIndex].childId} のマークアップ済み画像を保存しました。`, true); 
                updateTestSelector(); // 画像アイコンを更新
            }
            
            // ★変更点: 選択件数ではなく、リスト全体の件数でチェック
            if (testSpecs.length === 0) {
                showMessage("Markdownを生成するには、リストにテストケースが1件以上必要です。");
                return;
            }

            let combinedMarkdown = `# テスト証跡レポート\n\n---`;
            
            // ★変更点: 選択されたインデックスではなく、すべてのテストケースをループ
            testSpecs.forEach(spec => {
                if (spec) {
                    const dataURL = spec.evidenceImage || spec.originalImageSrc || 'No Image Data'; 
                    const singleCaseMarkdown = generateSingleCaseMarkdown(spec, dataURL);
                    combinedMarkdown += singleCaseMarkdown;
                }
            });

            // 2. 出力エリアに表示
            markdownOutput.value = combinedMarkdown;
            
            // 3. MarkdownをHTMLに変換し、プレビューエリアに表示
            previewOutput.innerHTML = marked.parse(combinedMarkdown);

            // 4. UIの状態更新
            copyButton.style.display = 'block';
            downloadButton.disabled = false;
            // ★変更点: メッセージを全件数ベースに変更
            showMessage(`✅ 全${testSpecs.length}件のテストケースのMarkdownを一括生成しました！`);
        });

        // ダウンロード
        function downloadFile(filename, text) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);

            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        downloadButton.addEventListener('click', () => {
            const content = markdownOutput.value;
            
            // ★変更点: selectedIndices.size を testSpecs.length に変更
            if (content && testSpecs.length > 0) {
                const firstSpec = testSpecs[0];
                const lastSpec = testSpecs[testSpecs.length - 1];
                
                let filename = `evidence_report`;
                // ★変更点: testSpecs.length でファイル名を判定
                if (testSpecs.length === 1) {
                    filename = `evidence_${firstSpec.parentId}-${firstSpec.childId}.md`;
                } else if (firstSpec && lastSpec) {
                    filename = `evidence_${firstSpec.parentId}-${firstSpec.childId}_to_${lastSpec.parentId}-${lastSpec.childId}.md`;
                }
                
                if (filename.endsWith('.md') === false) filename += '.md';
                
                downloadFile(filename, content);
                showMessage(`${filename} のダウンロードを開始しました。`);
            } else {
                showMessage("先にMarkdownを生成してください。");
            }
        });

        // コピー
        copyButton.addEventListener('click', () => {
            const content = markdownOutput.value;
            if (content) {
                // document.execCommand('copy') を使用
                const textarea = markdownOutput;
                textarea.select();
                textarea.setSelectionRange(0, 99999); 
                try {
                    document.execCommand('copy');
                    showMessage("Markdownコードをクリップボードにコピーしました！");
                } catch (err) {
                    console.error('コピー失敗:', err);
                    showMessage("コードのコピーに失敗しました。手動でコピーしてください。");
                }
                window.getSelection().removeAllRanges();
            }
        });

        // ツールバーのイベント設定
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const mode = button.getAttribute('data-mode');
                drawingMode = mode;
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            });
        });

        lineWidthInput.addEventListener('input', () => {
            lineWidthValue.textContent = lineWidthInput.value;
            ctx.lineWidth = parseInt(lineWidthInput.value);
        });

        clearButton.addEventListener('click', () => {
            if (focusedIndex === -1 || !originalImage) {
                 showMessage("画像をロードしたテストケースを選択してください。");
                 return;
            }
            if (confirm("現在のマークアップをすべて削除しますか？")) {
                drawings = [];
                // evidenceImage を null に戻す (再生成させるため)
                testSpecs[focusedIndex].evidenceImage = null; 
                redrawAll();
                showMessage("マークアップをクリアしました。");
            }
        });

        // 初期化とリサイズ対応
        window.addEventListener('resize', redrawAll);
        window.onload = () => {
            canvasSection.style.display = 'none';
        };

    </script>
</body>
</html>